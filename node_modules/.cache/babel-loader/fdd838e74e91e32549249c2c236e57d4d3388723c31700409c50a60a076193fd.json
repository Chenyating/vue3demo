{"ast":null,"code":"import TabBar from './tab-bar';\nimport { addResizeListener, removeResizeListener } from 'element-ui/src/utils/resize-event';\nfunction noop() {}\nconst firstUpperCase = str => {\n  return str.toLowerCase().replace(/( |^)[a-z]/g, L => L.toUpperCase());\n};\nexport default {\n  name: 'TabNav',\n  components: {\n    TabBar\n  },\n  inject: ['rootTabs'],\n  props: {\n    panes: Array,\n    currentName: String,\n    editable: Boolean,\n    onTabClick: {\n      type: Function,\n      default: noop\n    },\n    onTabRemove: {\n      type: Function,\n      default: noop\n    },\n    type: String,\n    stretch: Boolean\n  },\n  data() {\n    return {\n      scrollable: false,\n      navOffset: 0,\n      isFocus: false,\n      focusable: true\n    };\n  },\n  computed: {\n    navStyle() {\n      const dir = ['top', 'bottom'].indexOf(this.rootTabs.tabPosition) !== -1 ? 'X' : 'Y';\n      return {\n        transform: `translate${dir}(-${this.navOffset}px)`\n      };\n    },\n    sizeName() {\n      return ['top', 'bottom'].indexOf(this.rootTabs.tabPosition) !== -1 ? 'width' : 'height';\n    }\n  },\n  updated() {\n    this.update();\n  },\n  mounted() {\n    addResizeListener(this.$el, this.update);\n    document.addEventListener('visibilitychange', this.visibilityChangeHandler);\n    window.addEventListener('blur', this.windowBlurHandler);\n    window.addEventListener('focus', this.windowFocusHandler);\n    setTimeout(() => {\n      this.scrollToActiveTab();\n    }, 0);\n  },\n  beforeDestroy() {\n    if (this.$el && this.update) removeResizeListener(this.$el, this.update);\n    document.removeEventListener('visibilitychange', this.visibilityChangeHandler);\n    window.removeEventListener('blur', this.windowBlurHandler);\n    window.removeEventListener('focus', this.windowFocusHandler);\n  },\n  methods: {\n    scrollPrev() {\n      const containerSize = this.$refs.navScroll[`offset${firstUpperCase(this.sizeName)}`];\n      const currentOffset = this.navOffset;\n      if (!currentOffset) return;\n      const newOffset = currentOffset > containerSize ? currentOffset - containerSize : 0;\n      this.navOffset = newOffset;\n    },\n    scrollNext() {\n      const navSize = this.$refs.nav[`offset${firstUpperCase(this.sizeName)}`];\n      const containerSize = this.$refs.navScroll[`offset${firstUpperCase(this.sizeName)}`];\n      const currentOffset = this.navOffset;\n      if (navSize - currentOffset <= containerSize) return;\n      const newOffset = navSize - currentOffset > containerSize * 2 ? currentOffset + containerSize : navSize - containerSize;\n      this.navOffset = newOffset;\n    },\n    scrollToActiveTab() {\n      if (!this.scrollable) return;\n      const nav = this.$refs.nav;\n      const activeTab = this.$el.querySelector('.is-active');\n      if (!activeTab) return;\n      const navScroll = this.$refs.navScroll;\n      const isHorizontal = ['top', 'bottom'].indexOf(this.rootTabs.tabPosition) !== -1;\n      const activeTabBounding = activeTab.getBoundingClientRect();\n      const navScrollBounding = navScroll.getBoundingClientRect();\n      const maxOffset = isHorizontal ? nav.offsetWidth - navScrollBounding.width : nav.offsetHeight - navScrollBounding.height;\n      const currentOffset = this.navOffset;\n      let newOffset = currentOffset;\n      if (isHorizontal) {\n        if (activeTabBounding.left < navScrollBounding.left) {\n          newOffset = currentOffset - (navScrollBounding.left - activeTabBounding.left);\n        }\n        if (activeTabBounding.right > navScrollBounding.right) {\n          newOffset = currentOffset + activeTabBounding.right - navScrollBounding.right;\n        }\n      } else {\n        if (activeTabBounding.top < navScrollBounding.top) {\n          newOffset = currentOffset - (navScrollBounding.top - activeTabBounding.top);\n        }\n        if (activeTabBounding.bottom > navScrollBounding.bottom) {\n          newOffset = currentOffset + (activeTabBounding.bottom - navScrollBounding.bottom);\n        }\n      }\n      newOffset = Math.max(newOffset, 0);\n      this.navOffset = Math.min(newOffset, maxOffset);\n    },\n    update() {\n      if (!this.$refs.nav) return;\n      const sizeName = this.sizeName;\n      const navSize = this.$refs.nav[`offset${firstUpperCase(sizeName)}`];\n      const containerSize = this.$refs.navScroll[`offset${firstUpperCase(sizeName)}`];\n      const currentOffset = this.navOffset;\n      if (containerSize < navSize) {\n        const currentOffset = this.navOffset;\n        this.scrollable = this.scrollable || {};\n        this.scrollable.prev = currentOffset;\n        this.scrollable.next = currentOffset + containerSize < navSize;\n        if (navSize - currentOffset < containerSize) {\n          this.navOffset = navSize - containerSize;\n        }\n      } else {\n        this.scrollable = false;\n        if (currentOffset > 0) {\n          this.navOffset = 0;\n        }\n      }\n    },\n    changeTab(e) {\n      const keyCode = e.keyCode;\n      let nextIndex;\n      let currentIndex, tabList;\n      if ([37, 38, 39, 40].indexOf(keyCode) !== -1) {\n        // 左右上下键更换tab\n        tabList = e.currentTarget.querySelectorAll('[role=tab]');\n        currentIndex = Array.prototype.indexOf.call(tabList, e.target);\n      } else {\n        return;\n      }\n      if (keyCode === 37 || keyCode === 38) {\n        // left\n        if (currentIndex === 0) {\n          // first\n          nextIndex = tabList.length - 1;\n        } else {\n          nextIndex = currentIndex - 1;\n        }\n      } else {\n        // right\n        if (currentIndex < tabList.length - 1) {\n          // not last\n          nextIndex = currentIndex + 1;\n        } else {\n          nextIndex = 0;\n        }\n      }\n      tabList[nextIndex].focus(); // 改变焦点元素\n      tabList[nextIndex].click(); // 选中下一个tab\n      this.setFocus();\n    },\n    setFocus() {\n      if (this.focusable) {\n        this.isFocus = true;\n      }\n    },\n    removeFocus() {\n      this.isFocus = false;\n    },\n    visibilityChangeHandler() {\n      const visibility = document.visibilityState;\n      if (visibility === 'hidden') {\n        this.focusable = false;\n      } else if (visibility === 'visible') {\n        setTimeout(() => {\n          this.focusable = true;\n        }, 50);\n      }\n    },\n    windowBlurHandler() {\n      this.focusable = false;\n    },\n    windowFocusHandler() {\n      setTimeout(() => {\n        this.focusable = true;\n      }, 50);\n    }\n  },\n  render(h) {\n    const {\n      type,\n      panes,\n      editable,\n      stretch,\n      onTabClick,\n      onTabRemove,\n      navStyle,\n      scrollable,\n      scrollNext,\n      scrollPrev,\n      changeTab,\n      setFocus,\n      removeFocus\n    } = this;\n    const scrollBtn = scrollable ? [h(\"span\", {\n      \"class\": ['el-tabs__nav-prev', scrollable.prev ? '' : 'is-disabled'],\n      \"on\": {\n        \"click\": scrollPrev\n      }\n    }, [h(\"i\", {\n      \"class\": 'el-icon-arrow-left'\n    })]), h(\"span\", {\n      \"class\": ['el-tabs__nav-next', scrollable.next ? '' : 'is-disabled'],\n      \"on\": {\n        \"click\": scrollNext\n      }\n    }, [h(\"i\", {\n      \"class\": 'el-icon-arrow-right'\n    })])] : null;\n    const tabs = this._l(panes, (pane, index) => {\n      const tabName = pane.name || pane.index || index;\n      const closable = pane.isClosable || editable;\n      pane.index = `${index}`;\n      const btnClose = closable ? h(\"span\", {\n        \"class\": 'el-icon-close',\n        \"on\": {\n          \"click\": ev => {\n            onTabRemove(pane, ev);\n          }\n        }\n      }) : null;\n      const tabLabelContent = pane.$slots.label || pane.label;\n      const tabindex = pane.active ? 0 : -1;\n      return h(\"div\", {\n        \"class\": {\n          'el-tabs__item': true,\n          [`is-${this.rootTabs.tabPosition}`]: true,\n          'is-active': pane.active,\n          'is-disabled': pane.disabled,\n          'is-closable': closable,\n          'is-focus': this.isFocus\n        },\n        \"attrs\": {\n          \"id\": `tab-${tabName}`,\n          \"aria-controls\": `pane-${tabName}`,\n          \"role\": 'tab',\n          \"aria-selected\": pane.active,\n          \"tabindex\": tabindex\n        },\n        \"key\": `tab-${tabName}`,\n        \"ref\": 'tabs',\n        \"refInFor\": true,\n        \"on\": {\n          \"focus\": () => {\n            setFocus();\n          },\n          \"blur\": () => {\n            removeFocus();\n          },\n          \"click\": ev => {\n            removeFocus();\n            onTabClick(pane, tabName, ev);\n          },\n          \"keydown\": ev => {\n            if (closable && (ev.keyCode === 46 || ev.keyCode === 8)) {\n              onTabRemove(pane, ev);\n            }\n          }\n        }\n      }, [tabLabelContent, btnClose]);\n    });\n    return h(\"div\", {\n      \"class\": ['el-tabs__nav-wrap', scrollable ? 'is-scrollable' : '', `is-${this.rootTabs.tabPosition}`]\n    }, [scrollBtn, h(\"div\", {\n      \"class\": ['el-tabs__nav-scroll'],\n      \"ref\": 'navScroll'\n    }, [h(\"div\", {\n      \"class\": ['el-tabs__nav', `is-${this.rootTabs.tabPosition}`, stretch && ['top', 'bottom'].indexOf(this.rootTabs.tabPosition) !== -1 ? 'is-stretch' : ''],\n      \"ref\": 'nav',\n      \"style\": navStyle,\n      \"attrs\": {\n        \"role\": 'tablist'\n      },\n      \"on\": {\n        \"keydown\": changeTab\n      }\n    }, [!type ? h(\"tab-bar\", {\n      \"attrs\": {\n        \"tabs\": panes\n      }\n    }) : null, tabs])])]);\n  }\n};","map":{"version":3,"names":["TabBar","addResizeListener","removeResizeListener","noop","firstUpperCase","str","toLowerCase","replace","L","toUpperCase","name","components","inject","props","panes","Array","currentName","String","editable","Boolean","onTabClick","type","Function","default","onTabRemove","stretch","data","scrollable","navOffset","isFocus","focusable","computed","navStyle","dir","indexOf","rootTabs","tabPosition","transform","sizeName","updated","update","mounted","$el","document","addEventListener","visibilityChangeHandler","window","windowBlurHandler","windowFocusHandler","setTimeout","scrollToActiveTab","beforeDestroy","removeEventListener","methods","scrollPrev","containerSize","$refs","navScroll","currentOffset","newOffset","scrollNext","navSize","nav","activeTab","querySelector","isHorizontal","activeTabBounding","getBoundingClientRect","navScrollBounding","maxOffset","offsetWidth","width","offsetHeight","height","left","right","top","bottom","Math","max","min","prev","next","changeTab","e","keyCode","nextIndex","currentIndex","tabList","currentTarget","querySelectorAll","prototype","call","target","length","focus","click","setFocus","removeFocus","visibility","visibilityState","render","h","scrollBtn","tabs","_l","pane","index","tabName","closable","isClosable","btnClose","ev","tabLabelContent","$slots","label","tabindex","active","disabled","blur"],"sources":["node_modules/@cndinfo/cube-design-web/src/components/Tabs/src/tab-nav.vue"],"sourcesContent":["<script>\nimport TabBar from './tab-bar'\nimport { addResizeListener, removeResizeListener } from 'element-ui/src/utils/resize-event'\n\nfunction noop() { }\nconst firstUpperCase = str => {\n  return str.toLowerCase().replace(/( |^)[a-z]/g, (L) => L.toUpperCase())\n}\n\nexport default {\n  name: 'TabNav',\n  components: {\n    TabBar\n  },\n  inject: ['rootTabs'],\n  props: {\n    panes: Array,\n    currentName: String,\n    editable: Boolean,\n    onTabClick: {\n      type: Function,\n      default: noop\n    },\n    onTabRemove: {\n      type: Function,\n      default: noop\n    },\n    type: String,\n    stretch: Boolean\n  },\n  data() {\n    return {\n      scrollable: false,\n      navOffset: 0,\n      isFocus: false,\n      focusable: true\n    }\n  },\n  computed: {\n    navStyle() {\n      const dir = ['top', 'bottom'].indexOf(this.rootTabs.tabPosition) !== -1 ? 'X' : 'Y'\n      return {\n        transform: `translate${dir}(-${this.navOffset}px)`\n      }\n    },\n    sizeName() {\n      return ['top', 'bottom'].indexOf(this.rootTabs.tabPosition) !== -1 ? 'width' : 'height'\n    }\n  },\n  updated() {\n    this.update()\n  },\n  mounted() {\n    addResizeListener(this.$el, this.update)\n    document.addEventListener('visibilitychange', this.visibilityChangeHandler)\n    window.addEventListener('blur', this.windowBlurHandler)\n    window.addEventListener('focus', this.windowFocusHandler)\n    setTimeout(() => {\n      this.scrollToActiveTab()\n    }, 0)\n  },\n  beforeDestroy() {\n    if (this.$el && this.update) removeResizeListener(this.$el, this.update)\n    document.removeEventListener('visibilitychange', this.visibilityChangeHandler)\n    window.removeEventListener('blur', this.windowBlurHandler)\n    window.removeEventListener('focus', this.windowFocusHandler)\n  },\n  methods: {\n    scrollPrev() {\n      const containerSize = this.$refs.navScroll[`offset${firstUpperCase(this.sizeName)}`]\n      const currentOffset = this.navOffset\n\n      if (!currentOffset) return\n\n      const newOffset = currentOffset > containerSize\n        ? currentOffset - containerSize\n        : 0\n\n      this.navOffset = newOffset\n    },\n    scrollNext() {\n      const navSize = this.$refs.nav[`offset${firstUpperCase(this.sizeName)}`]\n      const containerSize = this.$refs.navScroll[`offset${firstUpperCase(this.sizeName)}`]\n      const currentOffset = this.navOffset\n\n      if (navSize - currentOffset <= containerSize) return\n\n      const newOffset = navSize - currentOffset > containerSize * 2\n        ? currentOffset + containerSize\n        : (navSize - containerSize)\n\n      this.navOffset = newOffset\n    },\n    scrollToActiveTab() {\n      if (!this.scrollable) return\n      const nav = this.$refs.nav\n      const activeTab = this.$el.querySelector('.is-active')\n      if (!activeTab) return\n      const navScroll = this.$refs.navScroll\n      const isHorizontal = ['top', 'bottom'].indexOf(this.rootTabs.tabPosition) !== -1\n      const activeTabBounding = activeTab.getBoundingClientRect()\n      const navScrollBounding = navScroll.getBoundingClientRect()\n      const maxOffset = isHorizontal\n        ? nav.offsetWidth - navScrollBounding.width\n        : nav.offsetHeight - navScrollBounding.height\n      const currentOffset = this.navOffset\n      let newOffset = currentOffset\n\n      if (isHorizontal) {\n        if (activeTabBounding.left < navScrollBounding.left) {\n          newOffset = currentOffset - (navScrollBounding.left - activeTabBounding.left)\n        }\n        if (activeTabBounding.right > navScrollBounding.right) {\n          newOffset = currentOffset + activeTabBounding.right - navScrollBounding.right\n        }\n      } else {\n        if (activeTabBounding.top < navScrollBounding.top) {\n          newOffset = currentOffset - (navScrollBounding.top - activeTabBounding.top)\n        }\n        if (activeTabBounding.bottom > navScrollBounding.bottom) {\n          newOffset = currentOffset + (activeTabBounding.bottom - navScrollBounding.bottom)\n        }\n      }\n      newOffset = Math.max(newOffset, 0)\n      this.navOffset = Math.min(newOffset, maxOffset)\n    },\n    update() {\n      if (!this.$refs.nav) return\n      const sizeName = this.sizeName\n      const navSize = this.$refs.nav[`offset${firstUpperCase(sizeName)}`]\n      const containerSize = this.$refs.navScroll[`offset${firstUpperCase(sizeName)}`]\n      const currentOffset = this.navOffset\n\n      if (containerSize < navSize) {\n        const currentOffset = this.navOffset\n        this.scrollable = this.scrollable || {}\n        this.scrollable.prev = currentOffset\n        this.scrollable.next = currentOffset + containerSize < navSize\n        if (navSize - currentOffset < containerSize) {\n          this.navOffset = navSize - containerSize\n        }\n      } else {\n        this.scrollable = false\n        if (currentOffset > 0) {\n          this.navOffset = 0\n        }\n      }\n    },\n    changeTab(e) {\n      const keyCode = e.keyCode\n      let nextIndex\n      let currentIndex, tabList\n      if ([37, 38, 39, 40].indexOf(keyCode) !== -1) { // 左右上下键更换tab\n        tabList = e.currentTarget.querySelectorAll('[role=tab]')\n        currentIndex = Array.prototype.indexOf.call(tabList, e.target)\n      } else {\n        return\n      }\n      if (keyCode === 37 || keyCode === 38) { // left\n        if (currentIndex === 0) { // first\n          nextIndex = tabList.length - 1\n        } else {\n          nextIndex = currentIndex - 1\n        }\n      } else { // right\n        if (currentIndex < tabList.length - 1) { // not last\n          nextIndex = currentIndex + 1\n        } else {\n          nextIndex = 0\n        }\n      }\n      tabList[nextIndex].focus() // 改变焦点元素\n      tabList[nextIndex].click() // 选中下一个tab\n      this.setFocus()\n    },\n    setFocus() {\n      if (this.focusable) {\n        this.isFocus = true\n      }\n    },\n    removeFocus() {\n      this.isFocus = false\n    },\n    visibilityChangeHandler() {\n      const visibility = document.visibilityState\n      if (visibility === 'hidden') {\n        this.focusable = false\n      } else if (visibility === 'visible') {\n        setTimeout(() => {\n          this.focusable = true\n        }, 50)\n      }\n    },\n    windowBlurHandler() {\n      this.focusable = false\n    },\n    windowFocusHandler() {\n      setTimeout(() => {\n        this.focusable = true\n      }, 50)\n    }\n  },\n  render(h) {\n    const {\n      type,\n      panes,\n      editable,\n      stretch,\n      onTabClick,\n      onTabRemove,\n      navStyle,\n      scrollable,\n      scrollNext,\n      scrollPrev,\n      changeTab,\n      setFocus,\n      removeFocus\n    } = this\n    const scrollBtn = scrollable\n      ? [\n        <span class={['el-tabs__nav-prev', scrollable.prev ? '' : 'is-disabled']} on-click={scrollPrev}><i class='el-icon-arrow-left'></i></span>,\n        <span class={['el-tabs__nav-next', scrollable.next ? '' : 'is-disabled']} on-click={scrollNext}><i class='el-icon-arrow-right'></i></span>\n      ] : null\n\n    const tabs = this._l(panes, (pane, index) => {\n      const tabName = pane.name || pane.index || index\n      const closable = pane.isClosable || editable\n\n      pane.index = `${index}`\n\n      const btnClose = closable\n        ? <span class='el-icon-close' on-click={(ev) => { onTabRemove(pane, ev) }}></span>\n        : null\n\n      const tabLabelContent = pane.$slots.label || pane.label\n      const tabindex = pane.active ? 0 : -1\n      return (\n        <div\n          class={{\n            'el-tabs__item': true,\n            [`is-${this.rootTabs.tabPosition}`]: true,\n            'is-active': pane.active,\n            'is-disabled': pane.disabled,\n            'is-closable': closable,\n            'is-focus': this.isFocus\n          }}\n          id={`tab-${tabName}`}\n          key={`tab-${tabName}`}\n          aria-controls={`pane-${tabName}`}\n          role='tab'\n          aria-selected={pane.active}\n          ref='tabs'\n          tabindex={tabindex}\n          refInFor\n          on-focus={() => { setFocus() }}\n          on-blur={() => { removeFocus() }}\n          on-click={(ev) => { removeFocus(); onTabClick(pane, tabName, ev) }}\n          on-keydown={(ev) => { if (closable && (ev.keyCode === 46 || ev.keyCode === 8)) { onTabRemove(pane, ev) } }}\n        >\n          {tabLabelContent}\n          {btnClose}\n        </div>\n      )\n    })\n    return (\n      <div class={['el-tabs__nav-wrap', scrollable ? 'is-scrollable' : '', `is-${this.rootTabs.tabPosition}`]}>\n        {scrollBtn}\n        <div class={['el-tabs__nav-scroll']} ref='navScroll'>\n          <div\n            class={['el-tabs__nav', `is-${this.rootTabs.tabPosition}`, stretch && ['top', 'bottom'].indexOf(this.rootTabs.tabPosition) !== -1 ? 'is-stretch' : '']}\n            ref='nav'\n            style={navStyle}\n            role='tablist'\n            on-keydown={changeTab}\n          >\n            {!type ? <tab-bar tabs={panes}></tab-bar> : null}\n            {tabs}\n          </div>\n        </div>\n      </div>\n    )\n  }\n}\n</script>\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}